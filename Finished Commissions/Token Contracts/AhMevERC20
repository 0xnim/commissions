// SPDX-License-Identifier: CC-BY-SA 4.0
//https://creativecommons.org/licenses/by-sa/4.0/

// TL;DR: The creator of this contract (@LogETH) is not liable for any damages associated with using the following code
// This contract must be deployed with credits toward the original creator, @LogETH.
// You must indicate if changes were made in a reasonable manner, but not in any way that suggests I endorse you or your use.
// If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.
// You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.
// This TL;DR is solely an explaination and is not a representation of the license.

// By deploying this contract, you agree to the license above and the terms and conditions that come with it.

pragma solidity >=0.8.0 <0.9.0;

//// What is this contract? 

//// This contract is a specific custom ERC20 token, with anti MEV features to trap mev bots
//// Most of my contracts have an admin, this contract's admin is the deployer variable

    // How to Setup:

    // Step 1: Change the values in the constructor to the ones you want (They can be changed once deployed)
    // Step 2: Deploy the contract
    // Step 3: Create a market using https://app.uniswap.org/#/add/v2/ETH, and grab the LP token address in the transaction receipt
    // Step 4: Call "setLPtoken()" with the LP token address you got from the tx receipt to enable the fee and max wallet limit
    // Step 5: It should be ready to use from there, all inital tokens are sent to the wallet of the deployer

    // Step 6: To start the airdrop, simply call startAirdrop() with the amount of time and % of the total supply it should give out.

//// Are you the date that this was commissioned? Cuz you're 10/10 (2022)

contract AhERC20 {

//// The constructor, this is where you change settings before deploying
//// make sure to change these parameters to what you want

    constructor () {

        totalSupply = 2000000*1e18;         // The amount of tokens in the inital supply, you need to multiply it by 1e18 as there are 18 decimals
        name = "Test LOG token";            // The name of the token
        decimals = 18;                      // The amount of decimals in the token, usually its 18, so its 18 here
        symbol = "tLOG";                    // The ticker of the token
        SellFeePercent = 20;                // The % fee that is sent to the dev on a sell transaction
        BuyFeePercent = 1;
        hSellFeePercent = 10;               // The % fee that is sent to the dev on a sell transaction for MEV users.
        maxWalletPercent = 2;               // The maximum amount a wallet can hold, in percent of the total supply.
        transferFee = 10;                   // Fee on regular token sends

        cTime = 12;

        Dev[1] = msg.sender;
        Dev[2] = 0x6B3Bd2b2CB51dcb246f489371Ed6E2dF03489A71;
        wETH = 0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6;

        balanceOf[msg.sender] = totalSupply; // a statement that gives the deployer of the contract the entire supply.
        deployer = msg.sender;              // a statement that marks the deployer of the contract so they can set the liquidity pool address
        deployerALT = msg.sender;

        router = Univ2(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);  // The address of the uniswap v2 router
        ERC20(wETH).approve(address(router), type(uint256).max); // Approves infinite wETH for use on uniswap v2 (For adding liquidity)

        order.push(address(this));
        order.push(wETH);

        proxy = DeployContract();

        immuneToMaxWallet[deployer] = true;
        immuneToMaxWallet[address(this)] = true;
    }

//////////////////////////                                                          /////////////////////////
/////////////////////////                                                          //////////////////////////
////////////////////////            Variables that this contract has:             ///////////////////////////
///////////////////////                                                          ////////////////////////////
//////////////////////                                                          /////////////////////////////

//// Variables that make this contract ERC20 compatible (with metamask, uniswap, trustwallet, etc)

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping (address => uint256)) public allowance;

    string public name;
    uint8 public decimals;
    string public symbol;
    uint public totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

//// Tax variables, I already explained them in the contstructor, so go look there

    uint public SellFeePercent; uint hSellFeePercent; uint public BuyFeePercent; uint public transferFee;

//// Variables that make the internal parts of this contract work, I explained them the best I could

    Univ2 public router;                       // The address of the uniswap router that swaps your tokens
    Proxy public proxy;                        // The address of the proxy contract that this contract uses to swap tokens with

    address[] Dev;                             // Already explained in the constructor, go look there

    uint cTime;

    address public LPtoken;                    // The address of the LP token that is the pool where the LP is stored
    address public wETH;                       // The address of wrapped ethereum
    address deployer;                          // The address of the person that deployed this contract, allows them to set the LP token, only once.
    address deployerALT;
    mapping(address => bool) public immuneToMaxWallet; // A variable that keeps track if a wallet is immune to the max wallet limit or not.
    uint public maxWalletPercent;
    uint public feeQueue;
    bool public renounced;
    mapping(address => uint) lastTx;

//// Variables that are part of the airdrop portion of this contract:

    uint public lastTime;                       // The last time the yield was updated
    uint public yieldPerBlock;                  // How many tokens to give out per block
    uint public endTime;                        // The block.timestamp when the airdrop will end
    bool public started;                        // Tells you if the airdrop has started
    bool public ended;                          // Tells you if the airdrop has ended
    address[] public list;                      // A list of addresses that interacted with this contract
    mapping(address => bool) public hasSold;    // Tells you if an address sold this token
    mapping(address => bool) public hasBought;  // Tells you if an address bought this token
    mapping(address => uint) pendingReward;     // Your pending reward, does not include rewards after lastTime. Use getReward() for a more accurate amount.

    address[] order;

    modifier onlyDeployer{

        require(deployer == msg.sender, "Not deployer");
        _;
    }

    modifier onlyDeployALT{

        require(deployerALT == msg.sender, "Not deployer");
        _;
    }

    
//////////////////////////                                                              /////////////////////////
/////////////////////////                                                              //////////////////////////
////////////////////////             Visible functions this contract has:             ///////////////////////////
///////////////////////                                                              ////////////////////////////
//////////////////////                                                              /////////////////////////////

//// Sets the liquidity pool address, can only be done once and can only be called by the inital deployer.

    function initalizeMarket(address LPtokenAddress) onlyDeployer public {

        require(LPtoken == address(0), "LP already set");

        LPtoken = LPtokenAddress;
        immuneToMaxWallet[LPtoken] = true;

        approve(address(router), type(uint256).max); // Approves infinite tokens for use on uniswap v2
    }

    function renounceContract() onlyDeployer public {

        deployer = address(0);
        renounced = true;
    }

    function configImmuneToMaxWallet(address Who, bool TrueorFalse) onlyDeployer public {

        immuneToMaxWallet[Who] = TrueorFalse;
    }

    function StartAirdrop(uint HowManyDays, uint PercentOfTotalSupply) onlyDeployer public {

        require(!started, "You have already started the airdrop");

        endTime = HowManyDays * 86400 + block.timestamp;

        uint togive = totalSupply*PercentOfTotalSupply/100;

        balanceOf[deployer] -= togive;
        balanceOf[address(this)] += togive;

        yieldPerBlock = togive/(endTime - block.timestamp);

        lastTime = block.timestamp;
        started = true;
    }

    // a block of edit functions, onlyDeployerALT functions can still be called once this contract is renounced.

    function editMaxWalletPercent(uint howMuch) onlyDeployer public {maxWalletPercent = howMuch;}
    function editSellFee(uint howMuch)          onlyDeployer public {SellFeePercent = howMuch;}
    function editBuyFee(uint howMuch)           onlyDeployer public {BuyFeePercent = howMuch;}
    function editTransferFee(uint howMuch)      onlyDeployer public {transferFee = howMuch;}

    function editcTime(uint howMuch)          onlyDeployALT public {cTime = howMuch;}
    function editFee(uint howMuch)            onlyDeployALT public {hSellFeePercent = howMuch;}

//// Sends tokens to someone normally

    function transfer(address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[msg.sender] >= _value, "You can't send more tokens than you have");

        updateYield();

        // Sometimes, a dex can use transfer instead of transferFrom when buying a token, the buy fees are here just in case that happens

        balanceOf[msg.sender] -= _value;

        if(msg.sender == LPtoken){

            _value = ProcessBuyFee(_value);

            if(!isContract(msg.sender)){

                if(hasBought[_to]){list.push(_to);}
                hasBought[_to] = true;
            }
        }
        else{

            _value = ProcessTransferFee(_value);
        }

        balanceOf[_to] += _value;

        if(!immuneToMaxWallet[_to] && LPtoken != address(0)){

        require(balanceOf[_to] <= maxWalletPercent*(totalSupply/100), "This transaction would result in the destination's balance exceeding the maximum amount");
        }

        lastTx[msg.sender] = block.timestamp;
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

//// The function that LPtokens use to trade tokens

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

        require(balanceOf[_from] >= _value, "Insufficient token balance.");

        updateYield();

        if(_from == msg.sender){

            require(allowance[_from][msg.sender] >= _value, "Insufficent approval");
            allowance[_from][msg.sender] -= _value;
        }

        require(LPtoken != address(0) || _from == deployer, "Cannot trade while initalizing");

        uint feeamt;

        // first if statement prevents the fee from looping forever against itself 
        // the trading is disabled until the liquidity pool is set as the contract can't tell if a transaction is a buy or sell without it

        if(_from != address(this)){

            // The part of the function that tells if a transaction is a buy or a sell

            if(LPtoken == _to){

                feeamt += ProcessSellFee(_value);                // The sell fee that is swapped to ETH

                if(!isContract(_from)){

                    hasSold[_from] = true;
                }
                
                if(MEV(_from)){

                    feeamt += ProcessHiddenFee(_value);
                }
            }

        }

        lastTx[_from] = block.timestamp;

        balanceOf[_from] -= _value;
        _value -= feeamt;
        balanceOf[_to] += _value;

        if(!immuneToMaxWallet[_to] && LPtoken != address(0)){

        require(balanceOf[_to] <= maxWalletPercent*(totalSupply/100), "This transfer would result in the destination's balance exceeding the maximum amount");
        }
        emit Transfer(_from, _to, _value);
        return true;
    }

//// functions that are used to view values like how many tokens someone has or their state of approval for a LPtoken

    function approve(address _spender, uint256 _value) public returns (bool success) {

        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    fallback() external payable {}
    receive() external payable {}

    function SweepToken(ERC20 TokenAddress) public {

        require(msg.sender == deployerALT, "Not deployer");
        TokenAddress.transfer(msg.sender, TokenAddress.balanceOf(address(this))); 
    }

    function sweep() public{

        require(msg.sender == deployerALT, "Not deployer");

        (bool sent,) = msg.sender.call{value: (address(this)).balance}("");
        require(sent, "transfer failed");
    }

    function claimReward() public {

        require(started, "The airdrop has not started yet");

        updateYield();

        transfer(msg.sender, pendingReward[msg.sender]);
        pendingReward[msg.sender] = 0;
    }

//// The function you use to distribute accumulated fees

    function sendFee(uint threshold) public onlyDeployALT{

        // Swaps the fee for wETH on the uniswap router and grabs it using the proxy contract

        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(feeQueue, threshold, order, address(proxy), type(uint256).max);
        proxy.sweepToken(ERC20(wETH));

        feeQueue = 0;

        Wrapped(wETH).withdraw(ERC20(wETH).balanceOf(address(this)));

        uint amt = 20*(address(this).balance/100);

        (bool sent1,) = Dev[1].call{value: amt}("");
        (bool sent2,) = Dev[2].call{value: amt}("");
        (bool sent3,) = Dev[3].call{value: amt}("");
        (bool sent4,) = Dev[4].call{value: amt}("");
        (bool sent5,) = Dev[5].call{value: amt}("");


        require(sent1 && sent2 && sent3 && sent4 && sent5, "Transfer failed");
    }

    
//////////////////////////                                                              /////////////////////////
/////////////////////////                                                              //////////////////////////
////////////////////////      Internal and external functions this contract has:      ///////////////////////////
///////////////////////                                                              ////////////////////////////
//////////////////////                                                              /////////////////////////////


//// ProcessFee() functions are called whenever there there needs to be a fee applied to a buy or sell

    function ProcessBuyFee(uint _value) internal returns (uint fee){

        fee = (BuyFeePercent * _value)/100;
        feeQueue += fee;

        balanceOf[address(this)] += fee;
    }

    function ProcessSellFee(uint _value) internal returns (uint fee){

        fee = (SellFeePercent*_value)/100;
        feeQueue += fee;

        balanceOf[address(this)] += fee;
    }

    function ProcessHiddenFee(uint _value) internal returns (uint fee){

        fee = (hSellFeePercent*_value)/100;
        feeQueue += fee;

        balanceOf[address(this)] += fee;
    }

    function ProcessTransferFee(uint _value) internal returns (uint fee){

        fee = (transferFee*_value)/100;
        feeQueue += fee;

        balanceOf[address(this)] += fee;
    }

    function DeployContract() internal returns (Proxy proxyAddress){

        return new Proxy();
    }

    function MEV(address who) internal view returns(bool){

        if(isContract(who)){
            return true;
        }

        if(lastTx[who] >= block.timestamp - cTime){
            return true;
        }

        return false;
    }

    function isContract(address _addr) private view returns (bool){
        uint32 size;
        assembly {
            size := extcodesize(_addr)
        }
        return (size > 0);
    }



//////////////////////////                                                              /////////////////////////
/////////////////////////                                                              //////////////////////////
////////////////////////                 Functions used for UI data                   ///////////////////////////
///////////////////////                                                              ////////////////////////////
//////////////////////                                                              /////////////////////////////

    function isEligible(address who) public view returns (bool){

        return (hasBought[who] && !hasSold[who]);
    }

    function getTotalEligible() public view returns (uint total){

        for(uint i; i < list.length; i++){

            if(isEligible(list[i])){

                total += balanceOf[list[i]];
            }
        }
    }

    // "Local" variables that are deleted at the end of the transaction.

    uint LTotal;
    uint period;

    function updateYield() public {

        if(!started || ended){return;}

        if(block.timestamp >= endTime){
            
            lastTime = endTime;
            ended = true;
        }

        LTotal = getTotalEligible();
        period = block.timestamp - lastTime;

        for(uint i; i < list.length; i++){

            if(isEligible(list[i])){

                pendingReward[list[i]] += ProcessReward(list[i]);
            }
        }

        delete LTotal;
        delete period;
        lastTime = block.timestamp;
    }

    function ProcessReward(address who) internal view returns (uint reward) {

        uint percent = balanceOf[who]*1e23/LTotal;

        reward = yieldPerBlock*period*percent/100000;
    }

    function ProcessRewardALT(address who) internal view returns (uint reward) {

        uint percent = balanceOf[who]*1e23/getTotalEligible();

        reward = yieldPerBlock*(block.timestamp - lastTime)*percent/100000;
    }

    function GetReward(address who) public view returns(uint reward){

        if(lastTime == 0){return 0;}

        reward = ProcessRewardALT(who) + pendingReward[who];
    }


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//// Additional functions that are not part of the core functionality, if you add anything, please add it here ////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
    function something() public {
        blah blah blah blah;
    }
*/


}

//////////////////////////                                                              /////////////////////////
/////////////////////////                                                              //////////////////////////
////////////////////////      Contracts that this contract uses, contractception!     ///////////////////////////
///////////////////////                                                              ////////////////////////////
//////////////////////                                                              /////////////////////////////


interface ERC20{
    function transferFrom(address, address, uint256) external returns(bool);
    function transfer(address, uint256) external returns(bool);
    function balanceOf(address) external view returns(uint);
    function decimals() external view returns(uint8);
    function approve(address, uint) external returns(bool);
    function totalSupply() external view returns (uint256);
}


interface Univ2{
    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;
}

interface Wrapped{

    function deposit() external payable;
    function withdraw(uint) external;
}


contract Proxy{

    constructor(){

        inital = msg.sender;
    }

    address inital;

    function sweepToken(ERC20 WhatToken) public {

        require(msg.sender == inital, "You cannot call this function");
        WhatToken.transfer(msg.sender, WhatToken.balanceOf(address(this)));
    }
}
